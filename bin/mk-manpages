#! /usr/bin/perl

package Local::MkManPages;

use strict;
use warnings;
use File::Basename qw(basename);
use File::Spec ();
use Getopt::Long qw(GetOptionsFromArray);
use Pod::Usage qw(pod2usage);
use Pod::Simple::XHTML;

__PACKAGE__->run(@ARGV);

sub Releases    { return (qw(master 1.1.1 1.1.0 1.0.2)) }
sub Dirs        { return (qw(apps crypto ssl
                             man1 man3 man5 man7)) }
sub Dir2Section { return ( apps => "man1", crypto => "man3", ssl => "man3" ) }

sub getRelease {
    my ( $class, $ver ) = @_;
    my %known = map { $_ => 1 } $class->Releases;
    return @_ != 2 ? %known : defined $known{$ver} ? $ver : undef;
}

sub run {
    my ( $class, @argv ) = @_;
    my $opt = $class->process_options(@argv);
    $class->cleanup( $opt->{WwwDir}, $opt->{RelVer} );
    exit $class->main( $opt->{SrcDir}, $opt->{WwwDir}, $opt->{RelVer} );
}

sub main {
    my ( $class, $srcdir, $wwwdir, $release ) = @_;

    foreach my $subdir ( $class->Dirs ) {
        my $dir = File::Spec->catfile( $srcdir, "doc", $subdir );
        if ( opendir( my $dh, $dir ) ) {
            while ( my $ent = readdir($dh) ) {
                next if $ent =~ /^\./;
                next if $ent !~ /\.pod$/;

                my $filename = File::Spec->catfile( $dir, $ent );
                my $basename = basename( $ent, ".pod" );
                my $title = $basename;
                # In addition to what getdata() gives us, we add a few
                # defaults of our own:
                #
                #       subdir  => "..."        # The original subdir
                #       sect    => "..."        # Output section subdir
                #       sectnum => n            # Default section number
                #
                my $tmp_sect = { $class->Dir2Section }->{$subdir} // $subdir;
                (my $tmp_sectnum = $tmp_sect) =~ s|^man||;
                my %data = (
                    subdir  => $subdir,
                    sect    => $tmp_sect,
                    sectnum => $tmp_sectnum,
                    $class->getdata( $filename, $basename )
                   );
                my $out = $class->genhtml( $release, $filename, $title,
                                           $basename, %data );
                my $outfile =
                    File::Spec->catfile( $wwwdir, "man$release", $data{sect},
                                         "$basename.html" );
                open( my $fh, ">", $outfile )
                    or $class->die("Can't open $outfile: $!");
                print $fh $out or $class->die("Can't print $outfile: $!");
                close($fh) or $class->die("Can't close $outfile: $!");

                foreach my $alt (grep { $_ ne $basename } @{$data{names}}) {
                    my $target = File::Spec->catfile( $wwwdir, "man$release",
                                                      $data{sect}, "$alt.html" );
                    if ( ! -f $target ) {
                        link( $outfile, $target )
                            or $class->die("Can't link $outfile to $target: $!");
                    }
                }
            }
        }
    }
}

# Generate a manpage
sub genhtml {
    my ( $class, $release, $filename, $title, $file, %data ) = @_;
    my $header = $class->htmlHeader( $title, %data );
    my $footer = $class->htmlFooter( $release, $file, %data );

    open( my $fh, $filename ) || $class->die("Can't open $filename: $!");
    my $infile = do { local $/; <$fh>; };

    # L<asdf...|qwer...> ==> L<qwer>
    $infile =~ s/L<[^|>]*\|([^>]+)>/L<$1>/g;

    # L<asdf(x)> --> L<asdf>
    $infile =~ s/L<([^>]+)\(\d\)>/L<$1>/g;

    my $out;
    my $pod = Pod::Simple::XHTML->new;
    $pod->html_h_level(3);
    $pod->perldoc_url_prefix("/docs/man$release/$data{sect}/");
    $pod->perldoc_url_postfix(".html");
    $pod->man_url_prefix("/docs/man$release/$data{sect}/");
    $pod->man_url_postfix(".html");
    $pod->html_header($header);
    $pod->html_footer($footer);
    $pod->output_string( \$out );
    $pod->parse_string_document($infile);
    return $out;
}

# Return diverse data from a manpage if available, currently:
# {
#    names       => [ ... ]             # list of all OTHER names
#    description => "text"              # the short description from NAME
#    section     => n                   # the section number
# }
sub getdata {
    my ( $class, $infile ) = @_;
    my %data = ();
    open( my $fh, "<", $infile ) or $class->die("Can't open $infile: $!");
    {
        local $/ = "";
        my $foundname = 0;
        while (<$fh>) {
            chop;
            s/\n/ /gm;
            if (/^=for comment openssl_manual_section:\s*(\d+)/) {
                $data{sectnum} = "$1";
                $data{sect} = "man$1";
            }
            elsif (/^=head1\s/) {
                $foundname = 0;
            }
            elsif ($foundname) {
                if (/ - /) {
                    $data{description} = $';
                    $_ = $`;
                    s/,\s+/,/g;
                    s/\s+,/,/g;
                    s/^\s+//g;
                    s/\s+$//g;
                    s/\s/_/g;
                    push @{$data{names}}, split ',';
                }
            }
            if (/^=head1\s+NAME\s*$/) {
                $foundname = 1;
            }
        }
    }
    return %data;
}

sub die {
    my $class = shift;
    $class->error(@_);
    exit(2);
}

sub error {
    my $class = shift;
    my $prog  = basename($0);
    warn("$prog: $_\n") for @_;
}

# Remove all files from a manpage subtree, and leave only
# the index and the section subdirs.
sub cleanup {
    my ( $class, $wwwdir, $release ) = @_;
    my $dir = File::Spec->catfile( $wwwdir, "man$release" );
    my $idx = File::Spec->catfile( $dir,    "index.html" );

    if ( !-d $dir ) {
        mkdir($dir) or $class->die("mkdir '$dir': $!");
    }

    # TBD: was $class->die
    $class->error("No $idx") unless ( -f $idx );
    foreach my $subdir ( $class->Dirs ) {
        my $realsubdir = { $class->Dir2Section }->{$subdir} // $subdir;
        my $realsdir = File::Spec->catfile( $dir, $realsubdir );
        if ( !-d $realsdir ) {
            mkdir($realsdir) or $class->die("mkdir '$realsdir': $!");
            next;
        }

        my $sdir = File::Spec->catfile( $dir, $subdir );
        if ( -d $sdir ) {
            opendir( my $dh, $sdir ) or $class->die("opendir '$sdir': $!");
            while ( my $ent = readdir($dh) ) {
                next if $ent =~ /^\./;
                next if $realsdir eq $sdir && $ent =~ /^index.(?:html|inc)$/;
                my $f = File::Spec->catfile( $sdir, $ent );
                unlink($f) or $class->error("Can't unlink '$f': $!");
            }
            closedir( $dh );

            if ( $realsubdir ne $subdir ) {
                rmdir $sdir;
            }
        }
    }
}

sub process_options {
    my ( $class, @argv ) = @_;
    my %opt;

    GetOptionsFromArray( \@argv, \%opt, "help", "man" )
      or pod2usage( -verbose => 0 );

    pod2usage( -verbose => 1 ) if ( $opt{help} or @argv != 3 );
    pod2usage( -verbose => 2 ) if ( $opt{man} );

    # <src/dir> <rel.ver> <www/dir>
    my @argkeys = qw(SrcDir RelVer WwwDir);
    @opt{@argkeys} = @argv;

    # no empty values, directories must exist
    my @err;
    foreach my $key (@argkeys) {
        push( @err, "Invalid $key argument '$opt{$key}'" )
          if ( $opt{$key} =~ /^\s*$/ );
        push( @err, "Directory '$opt{$key}': $!" )
          if ( $key =~ /Dir$/ and !-d $opt{$key} );
    }
    $class->die(@err) if @err;

    # each source dir has a set of subdirs with documentation
    my @found_dirs = ();
    my $docdir = File::Spec->catfile( $opt{SrcDir}, "doc" );
    foreach my $subdir ( $class->Dirs ) {
        my $dir = File::Spec->catfile( $docdir, $subdir );
        push @found_dirs, $dir if -d $dir;
    }
    push( @err, "No documentation directories in $docdir" )
        unless ( @found_dirs );

    # verify release
    push( @err, "Unknown release '$opt{RelVer}'" )
      unless ( $class->getRelease( $opt{RelVer} ) );
    $class->die(@err) if @err;

    return \%opt;
}

sub htmlHeader {
    my ( $class, $title, %data ) = @_;
    return <<EOFH;
<!DOCTYPE html>
<html lang="en">
<!-- OSSL: original subdir: $data{subdir} -->
<!-- OSSL: subdir: $data{sect} -->
<!-- OSSL: section: $data{sectnum} -->
<!-- OSSL: description: $data{description} -->
<!--#include virtual="/inc/head.shtml" -->
<body>
  <!--#include virtual="/inc/banner.shtml" -->
  <div id="main">
    <div id="content">
      <div class="blog-index">
        <article>
          <header><h2>$title</h2></header>
          <div class="entry-content">
            <p>

EOFH
}

# note: links could be bogus if file DNE in one of the other releases
sub htmlSidebar {
    my ( $class, $release, $file, %data ) = @_;

    my $lirel = "\n";
    foreach my $v ( grep { $release ne $_ } $class->Releases ) {
        $lirel .= <<EOS;
<li><a href="/docs/man$v/$data{sect}/$file.html">$v version</a></li>
EOS
    }

    return <<EOS;
<aside class="sidebar">
  <section>
    <h1><a href="/docs/man$release.html">$release manpages</a></h1>
    <ul>
      <li><a href="../man1">Commands</a></li>
      <li><a href="../man3">Libraries</a></li>
      <li><a href="../man5">File Formats</a></li>
      <li><a href="../man7">Overviews</a></li>
    </ul>
  </section>
  <section>
    <h1><a href="/docs/manpages.html">Manpages</a></h1>
    <ul>$lirel</ul>
  </section>
</aside>
EOS
}

sub htmlFooter {
    my ( $class, $release, $file, %data ) = @_;
    my $sidebar = $class->htmlSidebar( $release, $file, %data );
    return <<EOFT;
            </p>
          </div>
          <footer>
            You are here: <a href="/">Home</a>
            : <a href="/docs">Docs</a>
            : <a href="/docs/manpages.html">Manpages</a>
            : <a href="/docs/man$release">$release</a>
            : <a href="/docs/man$release/$data{sect}">$data{sect}</a>
            : <a href="/docs/man$release/$data{sect}/$file.html">$file</a>
            <br/><a href="/sitemap.txt">Sitemap</a>
          </footer>
        </article>
      </div>
      $sidebar
    </div>
  </div>
  <!--#include virtual="/inc/footer.shtml" -->
</body>
</html>
EOFT
}

__END__

=pod

=head1 NAME

mk-manpages - htmlize man pages from POD for the OpenSSL website

=head1 SYNOPSIS

mk-manpages [options] <SrcDir> <RelVer> <WwwDir>

  <SrcDir>   top level directory of release <RelVer>, example 'OpenSSL_1_0_2-stable'
  <RelVer>   version number associated with <SrcDir>, example '1.0.2'
  <WwwDir>   top level directory beneath which generated html is stored, example 'web'

    --help    display a brief help message
    --man     display full documentation

=head1 DESCRIPTION

This utility is run on a web server generate the htmlized version of
OpenSSL documentation from the original POD.  The resultant directory
structure may look something like the following (where the contents of
index.html do not come from this tool):

 $ ls some/path/to/web
 man1.0.2    man1.1.0    manmaster
 $ ls some/path/to/web/man1.0.2
 apps        crypto      index.html  ssl
 $ ls some/path/to/web/man1.0.2/apps
 CA.pl.html
 asn1parse.html
 c_rehash.html
 ...

=cut
